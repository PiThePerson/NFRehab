<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Glute Bridge Tracker</title>

    <!-- external styles -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <link rel="stylesheet" href="../css/ept.css" />
    <link rel="stylesheet" href="../css/main.css" />

    <style>
      .dashboard-overlay {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        padding: 15px;
        color: #fff;
        display: flex;
        flex-direction: column;
        gap: 10px;
        backdrop-filter: blur(5px);
      }
      .dashboard-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .back-button {
        color: #fff;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1rem;
      }
      .star-display {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1rem;
      }
      .dashboard-header {
        display: none;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      .video-wrapper {
        position: relative;
        flex-grow: 1;
        overflow: hidden;
      }
      #video,
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .hud {
        position: absolute;
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 1.05rem;
        font-weight: bold;
      }
      .top-left {
        top: 20px;
        left: 20px;
      }
      .top-right {
        top: 20px;
        right: 20px;
      }

      .status-indicator {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 0.95rem;
      }

      #feedback {
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        padding: 8px 20px;
        border-radius: 12px;
        font-size: 1.05rem;
        font-weight: bold;
        display: none;
        z-index: 20;
        white-space: nowrap;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.2);
        line-height: 1.4;
        min-width: 120px;
        text-align: center;
        backdrop-filter: blur(4px);
      }

      .quality-indicator {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      .quality-good {
        background: rgba(40, 167, 69, 0.7);
        color: #fff;
        padding: 6px 12px;
        border-radius: 8px;
      }
      .quality-warning {
        background: rgba(255, 193, 7, 0.7);
        color: #000;
        padding: 6px 12px;
        border-radius: 8px;
      }
      .quality-poor {
        background: rgba(220, 53, 69, 0.7);
        color: #fff;
        padding: 6px 12px;
        border-radius: 8px;
      }

      .controls {
        padding: 1rem;
        background-color: rgba(52, 73, 94, 0.7);
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }
      .controls button {
        background: linear-gradient(45deg, #ff6b6b, #ffa500);
        color: #fff;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .controls button:hover {
        opacity: 0.9;
      }
      .timer {
        color: #fff;
        font-weight: bold;
        margin-left: auto;
      }

      .squat-stats {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.5);
      }
      .stat-box {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1rem;
        min-width: 150px;
        text-align: center;
      }
      .stat-label {
        font-size: 0.9rem;
        color: #ccc;
      }
      .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #fff;
      }

      #winScreen {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      .win-content {
        background: rgba(30, 30, 40, 0.95);
        border-radius: 15px;
        padding: 30px;
        max-width: 600px;
        width: 90%;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .win-title {
        color: #fff;
        font-size: 2.2rem;
        margin-bottom: 16px;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
      }
      .time-display,
      .best-time-display {
        color: #fff;
        font-size: 1.2rem;
        margin: 10px 0;
      }
      .best-time-display {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
      .record-badge {
        background: gold;
        color: #333;
        padding: 5px 10px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.95rem;
      }
      #starsContainer {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      #starsContainer span {
        font-size: 2.2rem;
        animation: starPulse 1.5s infinite alternate;
      }
      @keyframes starPulse {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.2);
        }
      }
      .win-buttons {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-top: 20px;
        flex-wrap: wrap;
      }
      .win-buttons button {
        padding: 10px 22px;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .play-again-btn {
        background: linear-gradient(45deg, #ff6b6b, #ffa500);
        color: #fff;
      }
      .next-btn {
        background: linear-gradient(45deg, #1e90ff, #00bfff);
        color: #fff;
      }
      .win-buttons button:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .camera-control {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .camera-select {
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 0.5rem;
        max-width: 200px;
      }

      .chip {
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        font-size: 0.85rem;
      }

      @media (max-width: 768px) {
        .dashboard-overlay {
          top: 10px;
          left: 10px;
          padding: 10px;
        }
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .timer {
          margin-left: 0;
          text-align: center;
        }
        .squat-stats {
          flex-direction: column;
          align-items: center;
        }
        .win-buttons {
          flex-direction: column;
        }
        .win-buttons button {
          width: 100%;
        }
        .camera-control {
          width: 100%;
          justify-content: center;
        }
        .camera-select {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- DASHBOARD -->
    <div class="dashboard-overlay">
      <div class="dashboard-item">
        <a class="back-button" href="/dashboard.html"
          ><i class="fas fa-arrow-left"></i> Dashboard</a
        >
      </div>
      <div class="dashboard-item star-display">
        <i class="fas fa-star"></i> Stars: <span id="starBalance">0</span>
      </div>
    </div>

    <!-- MAIN -->
    <div class="main-container">
      <div class="video-wrapper">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div class="hud top-left" id="angleDisplay">Hip Angle: --°</div>
        <div class="hud top-right" id="counterDisplay">Glute Raises: 0</div>

        <div class="status-indicator" id="statusIndicator">
          <span class="chip" id="chipSide">side: --</span>
          <span class="chip" id="chipConf">conf: --</span>
          <span class="chip" id="chipAngle">angle: --°</span>
          <span class="chip" id="chipPhase">phase: --</span>
          <span class="chip" id="chipDeltaU">Δ↑: 0°</span>
          <span class="chip" id="chipDeltaD">Δ↓: 0°</span>
        </div>

        <div id="feedback"></div>
        <div id="qualityIndicator" class="quality-indicator quality-good">
          Ready ✅
        </div>
      </div>

      <!-- CONTROLS -->
      <div class="controls">
        <button id="startBtn">
          <i class="fas fa-play"></i> Start Tracking
        </button>
        <button id="resetBtn"><i class="fas fa-redo"></i> Reset Count</button>
        <button id="calibrateBtn">
          <i class="fas fa-cog"></i> Calibrate (not needed)
        </button>
        <button id="debugBtn"><i class="fas fa-bug"></i> Debug: On</button>
        <button onclick="location.href='eptsel.html'">
          Return to Selection Screen
        </button>

        <div class="camera-control">
          <label for="cameraSelect">Camera:</label>
          <select id="cameraSelect" class="camera-select"></select>
        </div>

        <div class="timer">⏱️ Time: <span id="sessionTime">0</span>s</div>
      </div>

      <!-- STATS -->
      <div class="squat-stats">
        <div class="stat-box">
          <div class="stat-label">Glute Raise Count</div>
          <div class="stat-value" id="squatCount">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Current Phase</div>
          <div class="stat-value" id="state">--</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Rule</div>
          <div class="stat-value" id="threshold">
            Δangle ≥ 10° up, then Δangle ≥ 10° down
          </div>
        </div>
      </div>
    </div>

    <!-- WIN -->
    <div id="winScreen" style="display: none">
      <div class="win-content">
        <h1 class="win-title">Workout Complete!</h1>
        <div class="time-display">Time: <span id="finalTime">00:00</span></div>
        <div class="best-time-display">
          Best Time: <span id="bestTime">--:--</span>
          <span class="record-badge" style="display: none">New Record!</span>
        </div>
        <div id="starsContainer" style="margin: 1rem 0"></div>
        <div class="win-buttons">
          <button class="play-again-btn" onclick="playAgain()">
            <i class="fas fa-redo"></i> Play Again
          </button>
          <button class="next-btn" onclick="nextLevel()">
            Next <i class="fas fa-arrow-right"></i>
          </button>
        </div>
      </div>
    </div>

    <!-- Mediapipe -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>

    <script>
      const LEG_CONNECTIONS = [
        [23, 25],
        [25, 27],
        [27, 29],
        [29, 31],
        [24, 26],
        [26, 28],
        [28, 30],
        [30, 32],
      ];
      const LEG_LANDMARKS = [23, 24, 25, 26, 27, 28, 29, 30, 31, 32];
      const TORSO_POINTS = [11, 12, 23, 24];

      const USER_KEY = "nf_loggedInUser",
        USERS_KEY = "nf_users",
        CAM_KEY = "nf_selectedCamera";
      const readDB = () => JSON.parse(localStorage.getItem(USERS_KEY) || "{}");
      const writeDB = (db) =>
        localStorage.setItem(USERS_KEY, JSON.stringify(db));
      const currentUser = () => localStorage.getItem(USER_KEY);

      class GluteBridgeDeltaCounter {
        constructor() {
          const cfg = JSON.parse(localStorage.getItem("exerciseMode") || "{}");

          // Delta rule
          this.DELTA = 10; // degrees change to qualify each leg of the rep
          this.MIN_SEG_MS = 140; // min time between extremas (debounce)
          this.DIR_EPS = 0.5; // degrees to consider direction change (noise guard)
          this.MIN_REP_GAP_MS = 250; // min time between reps

          // DOM
          this.video = document.getElementById("video");
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");

          // state
          this.targetReps = cfg.reps || 10;
          this.count = 0;
          this.isTracking = false;

          // smoothing
          this.historySize = 8;
          this.smoothing = 0.55;
          this.leftAngleHist = [];
          this.rightAngleHist = [];

          // peak/valley tracking
          this.lastAngle = null;
          this.dir = 0; // -1 falling, 0 flat, +1 rising
          this.lastPeak = null;
          this.lastPeakT = 0;
          this.lastValley = null;
          this.lastValleyT = 0;
          this.deltaUpHit = false; // got Δ↑ >= DELTA since last valley
          this.deltaDownHit = false; // got Δ↓ >= DELTA since last peak
          this.phase = "--";
          this.lastRepT = 0;

          // Pose
          this.pose = new Pose({
            locateFile: (f) =>
              `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`,
          });
          this.pose.setOptions({
            modelComplexity: 2,
            smoothLandmarks: true,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
          });
          this.pose.onResults((r) => this.onResults(r));

          // UI/camera
          this.bindEvents();
          this.startSession();
          this.loadStars();
          this.setupCamera();
        }

        loadStars() {
          const u = currentUser(),
            db = readDB();
          document.getElementById("starBalance").textContent =
            u && db[u] ? db[u].stars || 0 : 0;
        }
        addStars(n = 1) {
          const u = currentUser();
          if (!u) return;
          const db = readDB();
          if (!db[u]) db[u] = { stars: 0 };
          db[u].stars = (db[u].stars || 0) + n;
          writeDB(db);
          document.getElementById("starBalance").textContent = db[u].stars;
        }

        async setupCamera() {
          const sel = document.getElementById("cameraSelect");
          const devs = await navigator.mediaDevices.enumerateDevices();
          const cams = devs.filter((d) => d.kind === "videoinput");
          sel.innerHTML = "";
          cams.forEach((d, i) => {
            const o = document.createElement("option");
            o.value = d.deviceId;
            o.textContent = d.label || `Camera ${i + 1}`;
            sel.appendChild(o);
          });
          const saved = localStorage.getItem(CAM_KEY) || cams[0]?.deviceId;
          sel.value = saved;
          sel.onchange = (e) => {
            localStorage.setItem(CAM_KEY, e.target.value);
            this.openStream(e.target.value);
          };
          this.openStream(saved);
        }

        async openStream(id) {
          if (this.stream) this.stream.getTracks().forEach((t) => t.stop());
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: id ? { exact: id } : undefined,
                width: { ideal: 640 },
                height: { ideal: 480 },
              },
              audio: false,
            });
            this.video.srcObject = this.stream;
            await this.video.play();
            if (!this.raf) this.poseLoop();
          } catch (e) {
            alert("Camera error: " + e.message);
            console.error(e);
          }
        }

        poseLoop() {
          const step = async () => {
            if (this.isTracking && this.video.readyState >= 2) {
              await this.pose.send({ image: this.video });
            }
            this.raf = requestAnimationFrame(step);
          };
          step();
        }

        bindEvents() {
          document.getElementById("startBtn").onclick = () => this.toggle();
          document.getElementById("resetBtn").onclick = () => this.reset();
          document.getElementById("calibrateBtn").onclick = () =>
            alert("Delta mode: no calibration needed.");
          document.getElementById("debugBtn").onclick = () => {
            const el = document.getElementById("statusIndicator");
            const on = el.style.display !== "none";
            el.style.display = on ? "none" : "block";
            document.getElementById("debugBtn").innerHTML = on
              ? '<i class="fas fa-bug"></i> Debug: Off'
              : '<i class="fas fa-bug"></i> Debug: On';
          };
          window.addEventListener("storage", () => this.loadStars());
          document.addEventListener("visibilitychange", () => {
            if (!document.hidden) this.loadStars();
          });
        }

        startSession() {
          this.start = Date.now();
          this.timer = setInterval(() => {
            document.getElementById("sessionTime").textContent = Math.floor(
              (Date.now() - this.start) / 1000
            );
          }, 1000);
        }

        toggle() {
          this.isTracking = !this.isTracking;
          const btn = document.getElementById("startBtn");
          btn.innerHTML = this.isTracking
            ? "⏸️ Stop Tracking"
            : '<i class="fas fa-play"></i> Start Tracking';
          btn.style.background = this.isTracking
            ? "linear-gradient(45deg,#f44336,#ff9800)"
            : "linear-gradient(45deg,#ff6b6b,#ffa500)";
        }

        reset() {
          this.count = 0;
          this.lastAngle = null;
          this.dir = 0;
          this.lastPeak = null;
          this.lastPeakT = 0;
          this.lastValley = null;
          this.lastValleyT = 0;
          this.deltaUpHit = false;
          this.deltaDownHit = false;
          this.phase = "--";
          this.leftAngleHist = [];
          this.rightAngleHist = [];
          this.updateHUD();
        }

        onResults(res) {
          this.draw(res);
          if (res.poseLandmarks && this.isTracking) {
            const a = this.analyse(res.poseLandmarks);
            this.deltaStateMachine(a);
            this.updateHUD(a);
          }
        }

        ang(a, b, c) {
          const ab = [a.x - b.x, a.y - b.y],
            cb = [c.x - b.x, c.y - b.y];
          const dot = ab[0] * cb[0] + ab[1] * cb[1];
          const denom = Math.hypot(...ab) * Math.hypot(...cb);
          const cos = Math.max(-1, Math.min(1, dot / (denom || 1)));
          return (Math.acos(cos) * 180) / Math.PI;
        }
        smooth(v, arr) {
          arr.push(v);
          if (arr.length > this.historySize) arr.shift();
          let wSum = 0,
            wTot = 0;
          arr.forEach((x, i) => {
            const w = Math.pow(this.smoothing, arr.length - 1 - i);
            wSum += x * w;
            wTot += w;
          });
          return wSum / (wTot || 1);
        }
        vis(p) {
          return p && p.visibility != null ? p.visibility : 0;
        }

        analyse(lm) {
          const Ls = lm[11],
            Lh = lm[23],
            Lk = lm[25];
          const Rs = lm[12],
            Rh = lm[24],
            Rk = lm[26];

          const leftAngle = this.smooth(
            this.ang(Ls, Lh, Lk),
            this.leftAngleHist
          );
          const rightAngle = this.smooth(
            this.ang(Rs, Rh, Rk),
            this.rightAngleHist
          );

          const leftConf = 0.5 * this.vis(Lh) + 0.5 * this.vis(Lk);
          const rightConf = 0.5 * this.vis(Rh) + 0.5 * this.vis(Rk);
          const side = rightConf >= leftConf ? "right" : "left";

          const angle = Math.max(leftAngle, rightAngle);
          const conf = Math.max(leftConf, rightConf);

          this.guide =
            side === "right"
              ? { s: Rs, h: Rh, k: Rk }
              : { s: Ls, h: Lh, k: Lk };

          return { angle, conf, side };
        }

        deltaStateMachine(a) {
          if (a.conf < 0.12) {
            this.phase = "low-conf";
            this.quality("poor");
            return;
          }

          const now = performance.now();
          const ang = a.angle;

          if (this.lastAngle == null) {
            this.lastAngle = ang;
            this.phase = "init";
            return;
          }

          const d = ang - this.lastAngle;
          let curDir = 0;
          if (d > this.DIR_EPS) curDir = +1;
          else if (d < -this.DIR_EPS) curDir = -1;
          else curDir = this.dir; // keep previous if tiny change

          // detect direction change -> finalize an extrema at lastAngle
          if (this.dir !== 0 && curDir !== this.dir) {
            const extremaAngle = this.lastAngle;
            if (this.dir === +1 && curDir === -1) {
              // reached a PEAK
              this.lastPeak = extremaAngle;
              this.lastPeakT = now;
              this.phase = "peak";
              if (
                this.lastValley != null &&
                now - this.lastValleyT >= this.MIN_SEG_MS
              ) {
                const rise = this.lastPeak - this.lastValley;
                if (rise >= this.DELTA) {
                  this.deltaUpHit = true;
                }
              }
            } else if (this.dir === -1 && curDir === +1) {
              // reached a VALLEY
              this.lastValley = extremaAngle;
              this.lastValleyT = now;
              this.phase = "valley";
              if (
                this.lastPeak != null &&
                now - this.lastPeakT >= this.MIN_SEG_MS
              ) {
                const drop = this.lastPeak - this.lastValley;
                if (drop >= this.DELTA) {
                  this.deltaDownHit = true;
                }
              }
            }
          }

          // count when we’ve seen both legs of the cycle (up then down)
          if (
            this.deltaUpHit &&
            this.deltaDownHit &&
            now - this.lastRepT >= this.MIN_REP_GAP_MS
          ) {
            this.rep();
            this.lastRepT = now;
            // re-arm: keep the latest valley as the start for the next cycle
            this.deltaUpHit = false;
            this.deltaDownHit = false;
            // optional: if we just counted at a valley, keep lastValley; else wait for the next valley naturally
          }

          this.dir = curDir;
          this.lastAngle = ang;

          // quality indicator
          const q = this.deltaUpHit || this.deltaDownHit ? "good" : "warning";
          this.quality(q);

          // chips
          const du =
            this.lastPeak != null && this.lastValley != null
              ? Math.max(0, this.lastPeak - this.lastValley).toFixed(1)
              : "0.0";
          const dd = du; // same magnitude display; the flags tell which leg is hit
          document.getElementById("chipDeltaU").textContent = `Δ↑: ${du}°${
            this.deltaUpHit ? " ✓" : ""
          }`;
          document.getElementById("chipDeltaD").textContent = `Δ↓: ${dd}°${
            this.deltaDownHit ? " ✓" : ""
          }`;
        }

        rep() {
          this.count += 1;
          this.addStars();
          this.flash("Rep! ✅");
          if (this.count >= this.targetReps) this.finish();
        }

        finish() {
          clearInterval(this.timer);
          const total = Date.now() - this.start;
          document.getElementById("finalTime").textContent = this.fmt(total);

          const bestKey = "bestBridgeTime_delta";
          const bestPrev = parseInt(localStorage.getItem(bestKey) || 1e12, 10);
          if (total < bestPrev) {
            localStorage.setItem(bestKey, total);
            document.querySelector(".record-badge").style.display = "inline";
          }
          document.getElementById("bestTime").textContent = this.fmt(
            Math.min(bestPrev, total)
          );

          const box = document.getElementById("starsContainer");
          box.innerHTML = "";
          for (let i = 0; i < this.count; i++) {
            const s = document.createElement("span");
            s.textContent = "🌟";
            s.style.fontSize = "2rem";
            box.appendChild(s);
          }

          try {
            const h = JSON.parse(
              localStorage.getItem("therapySessions") || "[]"
            );
            h.push({
              date: new Date().toISOString(),
              mode: "normal",
              game: "Glute Bridge Tracker (Δ-angle)",
              duration: Math.round(total / 1000),
            });
            localStorage.setItem("therapySessions", JSON.stringify(h));
          } catch (e) {
            console.warn("history save failed", e);
          }

          document.getElementById("winScreen").style.display = "flex";
          this.isTracking = false;
          document.getElementById("startBtn").innerHTML =
            '<i class="fas fa-play"></i> Start Tracking';
        }

        fmt(ms) {
          const s = Math.floor(ms / 1000),
            m = Math.floor(s / 60);
          return `${String(m).padStart(2, "0")}:${String(s % 60).padStart(
            2,
            "0"
          )}`;
        }

        quality(q) {
          const el = document.getElementById("qualityIndicator");
          el.textContent =
            q === "good"
              ? "Good Movement ✅"
              : q === "warning"
              ? "Move Hips Up/Down ⚠️"
              : "Poor Detection ❌";
          el.className = `quality-indicator quality-${q}`;
        }

        flash(msg) {
          const f = document.getElementById("feedback");
          f.textContent = msg;
          f.style.display = "block";
          setTimeout(() => {
            f.style.display = "none";
          }, 1000);
        }

        draw(res) {
          const c = this.canvas,
            ctx = this.ctx;
          c.width = this.video.videoWidth || 640;
          c.height = this.video.videoHeight || 480;
          ctx.clearRect(0, 0, c.width, c.height);
          ctx.save();
          ctx.scale(-1, 1);
          ctx.drawImage(this.video, -c.width, 0, c.width, c.height);
          ctx.restore();
          if (res.poseLandmarks) this.drawSkeleton(res.poseLandmarks);
        }

        drawSkeleton(lm) {
          const c = this.canvas,
            ctx = this.ctx;
          ctx.save();
          ctx.scale(-1, 1);
          ctx.translate(-c.width, 0);
          drawConnectors(ctx, lm, LEG_CONNECTIONS, {
            color: "#00FFAA",
            lineWidth: 4,
          });
          drawLandmarks(
            ctx,
            LEG_LANDMARKS.map((i) => lm[i]),
            { color: "#FF0077", fillColor: "#FF0077", radius: 6 }
          );
          drawLandmarks(
            ctx,
            TORSO_POINTS.map((i) => lm[i]),
            { color: "#66ccff", fillColor: "#66ccff", radius: 4 }
          );
          if (this.guide) {
            const toXY = (p) => [p.x * c.width, p.y * c.height];
            ctx.lineWidth = 6;
            const [hx, hy] = toXY(this.guide.h),
              [sx, sy] = toXY(this.guide.s),
              [kx, ky] = toXY(this.guide.k);
            ctx.strokeStyle = "#00FF00";
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(sx, sy);
            ctx.stroke();
            ctx.strokeStyle = "#00BFFF";
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(kx, ky);
            ctx.stroke();
            ctx.fillStyle = "#FFD700";
            ctx.beginPath();
            ctx.arc(hx, hy, 8, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        updateHUD(a = null) {
          document.getElementById("squatCount").textContent = this.count;
          document.getElementById(
            "counterDisplay"
          ).textContent = `Glute Raises: ${this.count}`;
          document.getElementById("state").textContent = this.phase;

          if (a) {
            document.getElementById(
              "angleDisplay"
            ).textContent = `Hip Angle: ${Math.round(a.angle)}°`;
            document.getElementById(
              "chipAngle"
            ).textContent = `angle: ${Math.round(a.angle)}°`;
            document.getElementById("chipSide").textContent = `side: ${a.side}`;
            document.getElementById(
              "chipConf"
            ).textContent = `conf: ${a.conf.toFixed(2)}`;
            document.getElementById(
              "chipPhase"
            ).textContent = `phase: ${this.phase}`;
          }
        }
      }

      window.addEventListener("load", () => new GluteBridgeDeltaCounter());

      function playAgain() {
        document.getElementById("winScreen").style.display = "none";
        location.reload();
      }
      function nextLevel() {
        document.getElementById("winScreen").style.display = "none";
      }
    </script>
  </body>
</html>
