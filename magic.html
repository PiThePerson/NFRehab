<!DOCTYPE html>
<html lang="en">
  <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
     ‚ïë  MAGIC.HTML  ‚Äì  Skins gallery + Memory-Match game (full page)     ‚ïë
     ‚ïë  Per-skin front artwork + per-skin shape colour                   ‚ïë
     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeuronFrames ‚Ä¢ Skins & Memory Match</title>

    <!-- styles --------------------------------------------------------- -->
    <link rel="stylesheet" href="css/pts.css" />
    <link rel="stylesheet" href="css/main.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />

    <style>
      /* ---------- generic layout ---------- */
      body {
        background: linear-gradient(
          270deg,
          #3ce3a4 0%,
          #35d8ca 43%,
          #31d1e1 58%,
          #2fc9ff 100%
        );
        min-height: 100vh;
        margin: 0;
        font-family: "Segoe UI", sans-serif;
      }

      .top-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        padding: 12px 20px;
        background: rgba(0, 0, 0, 0.25);
        color: #fff;
        font-weight: 600;
      }
      .back-button {
        color: #0d99ff;
        text-decoration: none;
        font-size: 1.05rem;
      }
      .star-display {
        font-size: 1.05rem;
      }

      /* ---------- skin gallery ---------- */
      .skins-section {
        padding: 1.2rem 1.8rem;
        background: #ffffffd0;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        border-radius: 14px;
        max-width: 900px;
        margin: 18px auto 0;
      }
      .skins-grid {
        display: flex;
        gap: 20px;
        margin-top: 14px;
        overflow-x: auto;
        padding-bottom: 8px;
        scrollbar-width: none;
      }
      .skins-grid::-webkit-scrollbar {
        display: none;
      }
      .skins-grid img {
        flex: 0 0 140px;
        height: 200px;
        object-fit: cover;
        border-radius: 12px;
        cursor: pointer;
        border: 4px solid transparent;
        transition: border-color 0.25s, transform 0.25s, box-shadow 0.25s;
      }

      /* ---------- play area ---------- */
      .game-area {
        max-width: 1000px;
        margin: 100px auto;
        position: relative;
        overflow: hidden;
      }
      .video-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        margin: 0 auto;
      }
      #video,
      #canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
      }
      .hud {
        position: absolute;
        font-weight: 600;
        color: #fff;
        text-shadow: 0 0 6px rgba(0, 0, 0, 0.7);
      }
      .hud.top-left {
        top: 8px;
        left: 14px;
      }
      .hud.top-right {
        top: 8px;
        right: 14px;
      }
      .controls {
        position: absolute;
        bottom: 350px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 14px;
      }
      .controls button {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background: #0d99ff;
        color: #fff;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      }
      .controls .timer {
        color: #fff;
        font-weight: 600;
        margin-left: 8px;
      }

      /* ---------- win screen (unchanged) ---------- */
      #winScreen {
        position: fixed;
        inset: 0;
        backdrop-filter: blur(6px);
        background: rgba(0, 0, 0, 0.55);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 2000;
      }
      #winScreen,
      #winScreen * {
        pointer-events: auto;
      }
      .win-content {
        background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        border-radius: 18px;
        padding: 36px 44px;
        text-align: center;
        box-shadow: 0 8px 36px rgba(0, 0, 0, 0.35);
        color: #fff;
      }
      .win-title {
        font-size: 2.4rem;
        font-weight: 800;
        margin: 0 0 16px;
        background-image: linear-gradient(
          90deg,
          #ffe53b 0%,
          #ff2525 30%,
          #ff53d1 60%,
          #12d8fa 85%,
          #a6ffcb 100%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
      .time-display,
      .best-time-display {
        font-size: 1.25rem;
        font-weight: 600;
        margin: 6px 0;
        color: #51ff92;
      }
      #starsContainer {
        margin-top: 8px;
        font-size: 1.2rem;
      }
      .win-buttons {
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-top: 20px;
      }
      .win-buttons button {
        padding: 10px 22px;
        border: none;
        border-radius: 10px;
        font-weight: 700;
        font-size: 1.05rem;
        cursor: pointer;
        background: linear-gradient(135deg, #12d8fa 0%, #a6ffcb 100%);
        color: #003046;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        transition: transform 0.15s;
      }
      .win-buttons button:hover {
        transform: translateY(-2px);
      }

      html,
      body {
        min-height: 100%;
        overflow-y: auto;
      }
      .game-area {
        overflow: visible !important;
        min-height: 100vh;
      }
    </style>

    <!-- external libs (Mediapipe) -------------------------------------- -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  </head>

  <body>
    <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  TOP BAR  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù -->
    <div class="top-bar">
      <a href="dashboard.html" class="back-button"
        ><i class="fas fa-arrow-left"></i> Back to Dashboard</a
      >
      <div class="star-display" id="starCount">
        üåü <span id="starBalance">0</span>
      </div>
    </div>

    <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  SKIN GALLERY  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó -->
    <section class="skins-section">
      <h2>üé® Pick Your Card-Back Skin</h2>
      <p class="gallery-info">Your Inventory</p>
      <div class="skins-grid" id="skinGallery"></div>
    </section>

    <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  GAME AREA  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó -->
    <div class="game-area">
      <div class="video-wrapper">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <div class="hud top-left" id="currentTime">Time: 0s</div>
        <div class="hud top-right" id="bestTime">Best: --</div>
      </div>

      <div class="controls">
        <button id="startBtn"><i class="fas fa-play"></i> Start Game</button>
        <div class="timer">‚è±Ô∏è Time: <span id="sessionTime">0</span>s</div>
      </div>
    </div>

    <!-- WIN SCREEN -->
    <div id="winScreen" style="display: none">
      <div class="win-content">
        <div class="win-title">CONGRATULATIONS!</div>
        <div class="time-display" id="timeDisplay">Time: 0s</div>
        <div class="best-time-display" id="bestTimeDisplay">Best Time: --</div>
        <div id="starsContainer"></div>
        <div class="win-buttons">
          <button id="playAgainBtn">
            <i class="fas fa-redo"></i> Play Again
          </button>
        </div>
      </div>
    </div>

    <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  SCRIPT  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó -->
    <script>
      /* üÜï‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         STAR-SYNC
      ------------------------------------------------------------------*/
      const USER_KEY = "nf_loggedInUser";
      const USERS_KEY = "nf_users";
      function refreshStars() {
        const u = localStorage.getItem(USER_KEY);
        const db = JSON.parse(localStorage.getItem(USERS_KEY) || "{}");
        if (!u || !db[u]) {
          window.location.href = "login.html";
          return;
        }
        document.getElementById("starBalance").textContent = db[u].stars ?? 0;
      }
      refreshStars();
      window.addEventListener("storage", refreshStars);
      window.addEventListener("focus", refreshStars);
      /* üÜï‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ USER / STAR INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const user = localStorage.getItem("nf_loggedInUser");
      const users = JSON.parse(localStorage.getItem("nf_users") || "{}");
      if (user && users[user])
        document.getElementById("starBalance").textContent =
          users[user].stars || 0;

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ AVAILABLE SKINS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const availableSkins = [
        /* SPECIAL FOUR */
        "images/card1.png",
        "images/card2.png",
        "images/cardI.jpg",
        "images/TF.jpg",
        /* OTHERS (plain white + black shape) */
        "images/cardA.jpg",
        "images/cardB.jpg",
        "images/cardC.jpg",
        "images/cardD.jpg",
        "images/cardE.jpg",
        "images/cardF.jpg",
        "images/cardG.jpg",
        "images/cardH.jpg",
        "images/cardJ.jpg",
        "images/cardK.jpg" /* will be edited later */,
      ];
      const defaultSkin = "images/card1.png";

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FRONT ART MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const skinFrontMap = {
        "images/card2.png": "images/Pp.jpg",
        "images/cardI.jpg": "images/moon.png",
        "images/TF.jpg": "images/TF1.jpg",
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SHAPE COLOUR MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const shapeColorMap = {
        "images/card1.png": "#000000",
        "images/card2.png": "#ffffff",
        "images/cardI.jpg": "#ffffff",
        "images/TF.jpg": "#ffffff",
        // others default to black
      };

      /* helper: current colour */
      function currentShapeColor() {
        return shapeColorMap[currentBackSkin] || "#000000";
      }

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GALLERY LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      function setSkin(file) {
        localStorage.setItem("nf_skin", file);
        cardBackImg.src = file;
        chooseFrontFor(file);
        currentBackSkin = file;
        updateGalleryUI();
        showToast("Skin changed! Starting a new round‚Ä¶");
        document
          .querySelector(".game-area")
          .scrollIntoView({ behavior: "smooth" });
        resetGame();
      }
      function getSkin() {
        return localStorage.getItem("nf_skin") || defaultSkin;
      }
      function updateGalleryUI() {
        const chosen = getSkin();
        document
          .querySelectorAll(".skins-grid img")
          .forEach((img) =>
            img.classList.toggle("active", img.dataset.file === chosen)
          );
      }
      function showToast(msg) {
        const t = document.createElement("div");
        t.textContent = msg;
        Object.assign(t.style, {
          position: "fixed",
          bottom: "20px",
          left: "50%",
          transform: "translateX(-50%)",
          background: "#333",
          color: "#fff",
          padding: "10px 18px",
          borderRadius: "8px",
          zIndex: 9999,
          opacity: 0,
          transition: "opacity .35s",
        });
        document.body.appendChild(t);
        requestAnimationFrame(() => (t.style.opacity = 1));
        setTimeout(() => {
          t.style.opacity = 0;
          setTimeout(() => t.remove(), 350);
        }, 2000);
      }

      /* build gallery */
      const gallery = document.getElementById("skinGallery");
      availableSkins.forEach((file) => {
        const img = document.createElement("img");
        img.src = file;
        img.alt = `Skin ${file}`;
        img.dataset.file = file;
        img.onclick = () => setSkin(file);
        gallery.appendChild(img);
      });
      updateGalleryUI();

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRELOAD BACK & FRONT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      let currentBackSkin = getSkin();
      const cardBackImg = new Image();
      cardBackImg.src = currentBackSkin;

      const cardFrontImg = new Image();
      function chooseFrontFor(backFile) {
        cardFrontImg.src = skinFrontMap[backFile] || "";
      }
      chooseFrontFor(currentBackSkin);

      window.addEventListener("storage", (e) => {
        if (e.key === "nf_skin") {
          const newSkin = getSkin();
          cardBackImg.src = newSkin;
          chooseFrontFor(newSkin);
          currentBackSkin = newSkin;
          updateGalleryUI();
        }
      });

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CANVAS / VIDEO SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const videoElement = document.getElementById("video");
      const canvasElement = document.getElementById("canvas");
      const ctx = canvasElement.getContext("2d");
      canvasElement.width = window.innerWidth;
      canvasElement.height = window.innerHeight;

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GAME CONSTANTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const CARD_ROWS = 2,
        CARD_COLS = 5,
        CARD_WIDTH = 200,
        CARD_HEIGHT = 250,
        CARD_MARGIN = 30,
        FLIP_HOLD_TIME = 1500,
        FLIP_DURATION = 600,
        PREVIEW_DURATION = 2000;

      const shapes = ["circle", "square", "triangle", "star", "hex", "diamond"];
      const cards = [];
      let selectedCards = [];
      let startTime = null,
        bestTime = null;
      let gameStarted = false,
        revealTimeout = null;

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Card Class ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      class Card {
        constructor(x, y, shape) {
          this.x = x;
          this.y = y;
          this.shape = shape;
          this.isFlipped = false;
          this.isMatched = false;
          this.flipProgress = 1;
          this.targetFaceUp = false;
          this.flipStart = null;
          this.hoverStart = null;
        }
        startFlip(faceUp) {
          if (this.targetFaceUp === faceUp && this.flipStart === null) return;
          this.targetFaceUp = faceUp;
          this.flipStart = performance.now();
        }
        tickFlip(now) {
          if (this.flipStart == null) return false;
          const t = Math.min((now - this.flipStart) / FLIP_DURATION, 1);
          const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          this.flipProgress = this.targetFaceUp ? 1 - ease : ease;
          if (t === 1) {
            this.flipStart = null;
            this.isFlipped = this.targetFaceUp;
          }
          return true;
        }
        draw(ctx) {
          ctx.save();
          const angle = (1 - this.flipProgress) * Math.PI;
          ctx.translate(this.x + CARD_WIDTH / 2, this.y);
          ctx.scale(Math.cos(angle), 1);
          ctx.translate(-CARD_WIDTH / 2, 0);

          if (!this.isFlipped && !this.isMatched) {
            if (cardBackImg.complete) {
              ctx.drawImage(cardBackImg, 0, 0, CARD_WIDTH, CARD_HEIGHT);
            } else {
              ctx.fillStyle = "#3366ff";
              ctx.fillRect(0, 0, CARD_WIDTH, CARD_HEIGHT);
            }
          } else {
            if (cardFrontImg.naturalWidth) {
              ctx.drawImage(cardFrontImg, 0, 0, CARD_WIDTH, CARD_HEIGHT);
            } else {
              ctx.fillStyle = "#ffffff";
              ctx.fillRect(0, 0, CARD_WIDTH, CARD_HEIGHT);
            }

            ctx.fillStyle = currentShapeColor();
            const cx = CARD_WIDTH / 2,
              cy = CARD_HEIGHT / 2;
            ctx.beginPath();
            switch (this.shape) {
              case "circle":
                ctx.arc(cx, cy, 40, 0, 2 * Math.PI);
                break;
              case "square":
                ctx.rect(cx - 40, cy - 40, 80, 80);
                break;
              case "triangle":
                ctx.moveTo(cx, cy - 50);
                ctx.lineTo(cx - 50, cy + 40);
                ctx.lineTo(cx + 50, cy + 40);
                ctx.closePath();
                break;
              case "hex":
                for (let i = 0; i < 6; i++) {
                  const a = (Math.PI / 3) * i - Math.PI / 6;
                  const x = cx + 50 * Math.cos(a);
                  const y = cy + 50 * Math.sin(a);
                  i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
                }
                ctx.closePath();
                break;
              case "star":
                for (let i = 0; i < 10; i++) {
                  const a = (Math.PI / 5) * i - Math.PI / 2;
                  const r = i % 2 ? 20 : 50;
                  const x = cx + r * Math.cos(a);
                  const y = cy + r * Math.sin(a);
                  i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
                }
                ctx.closePath();
                break;
              case "diamond":
                ctx.moveTo(cx, cy - 60);
                ctx.lineTo(cx + 50, cy);
                ctx.lineTo(cx, cy + 60);
                ctx.lineTo(cx - 50, cy);
                ctx.closePath();
                break;
            }
            ctx.fill();
          }
          ctx.restore();
        }
        contains(x, y) {
          return (
            x >= this.x &&
            x <= this.x + CARD_WIDTH &&
            y >= this.y &&
            y <= this.y + CARD_HEIGHT
          );
        }
      }

      /* helper fns */
      function createCards() {
        const total = CARD_ROWS * CARD_COLS;
        const pool = [];
        for (let i = 0; i < total / 2; i++)
          pool.push(shapes[i % shapes.length], shapes[i % shapes.length]);
        for (let i = pool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        cards.length = 0;
        const startX =
          (canvasElement.width -
            (CARD_COLS * CARD_WIDTH + (CARD_COLS - 1) * CARD_MARGIN)) /
          2;
        const startY =
          (canvasElement.height -
            (CARD_ROWS * CARD_HEIGHT + (CARD_ROWS - 1) * CARD_MARGIN)) /
          2;
        for (let r = 0; r < CARD_ROWS; r++) {
          for (let c = 0; c < CARD_COLS; c++) {
            const x = startX + c * (CARD_WIDTH + CARD_MARGIN);
            const y = startY + r * (CARD_HEIGHT + CARD_MARGIN);
            cards.push(new Card(x, y, pool.pop()));
          }
        }
      }
      function drawCards() {
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(
          videoElement,
          -canvasElement.width,
          0,
          canvasElement.width,
          canvasElement.height
        );
        ctx.restore();

        const now = performance.now();
        let needsRedraw = false;
        cards.forEach((c) => {
          if (c.tickFlip(now)) needsRedraw = true;
          c.draw(ctx);
        });
        if (needsRedraw) requestAnimationFrame(drawCards);
      }
      function updateTimer() {
        if (!gameStarted) return;
        const el = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById("sessionTime").textContent = el;
        document.getElementById("currentTime").textContent = `Time: ${el}s`;
      }
      function checkWin() {
        return cards.every((c) => c.isMatched);
      }
      function showWinScreen() {
        const el = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById("timeDisplay").textContent = `Time: ${el}s`;
        if (bestTime === null || el < bestTime) {
          bestTime = el;
          document.getElementById(
            "bestTimeDisplay"
          ).textContent = `Best Time: ${bestTime}s`;
        }
        if (user && users[user]) {
          users[user].stars = (users[user].stars || 0) + 10;
          localStorage.setItem("nf_users", JSON.stringify(users));
          /* üÜï badge refresh */
          refreshStars();
          document.getElementById(
            "starsContainer"
          ).innerHTML = `üåü You earned <strong>10</strong> stars!`;
        }
        document.getElementById("winScreen").style.display = "flex";
      }
      function revealCards() {
        cards.forEach((c) => c.startFlip(true));
        drawCards();
        revealTimeout = setTimeout(() => {
          cards.forEach((c) => c.startFlip(false));
          startTime = Date.now();
          gameStarted = true;
        }, PREVIEW_DURATION);
      }
      function resetGame() {
        if (revealTimeout) clearTimeout(revealTimeout);
        createCards();
        selectedCards = [];
        gameStarted = false;
        document.getElementById("winScreen").style.display = "none";
        revealCards();
      }

      /* DOM Events */
      document.getElementById("startBtn").addEventListener("click", resetGame);
      document
        .getElementById("playAgainBtn")
        .addEventListener("click", resetGame);

      /* Mediapipe hover */
      const hands = new Hands({
        locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5,
      });
      hands.onResults((results) => {
        if (!gameStarted) {
          drawCards();
          return;
        }
        const now = Date.now();
        const points = [];
        if (results.multiHandLandmarks) {
          for (const lm of results.multiHandLandmarks) {
            const tip = lm[8];
            points.push({
              x: canvasElement.width - tip.x * canvasElement.width,
              y: tip.y * canvasElement.height,
            });
          }
        }
        for (const card of cards) {
          let hover = false;
          for (const p of points) {
            if (card.contains(p.x, p.y)) {
              hover = true;
              if (!card.hoverStart) card.hoverStart = now;
              else if (
                now - card.hoverStart >= FLIP_HOLD_TIME &&
                !card.targetFaceUp &&
                selectedCards.length < 2
              ) {
                card.startFlip(true);
                selectedCards.push(card);
                card.hoverStart = null;
              }
              break;
            }
          }
          if (!hover) card.hoverStart = null;
        }
        if (selectedCards.length === 2) {
          const [c1, c2] = selectedCards;
          if (c1.shape === c2.shape) {
            c1.isMatched = c2.isMatched = true;
            selectedCards = [];
            if (checkWin()) {
              gameStarted = false;
              showWinScreen();
            }
          } else {
            setTimeout(() => {
              c1.startFlip(false);
              c2.startFlip(false);
              selectedCards = [];
            }, 1000);
          }
        }
        drawCards();
        updateTimer();
      });

      /* start cam */
      const camera = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: canvasElement.width,
        height: canvasElement.height,
      });
      camera.start();
    </script>
  </body>
</html>
